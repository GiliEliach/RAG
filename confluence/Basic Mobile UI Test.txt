Basic Mobile UI Test
I can imagine the first thing you will want to do is to write a very simple and basic test - to heat up the engines. This page will guide you 
through the code:
Click here to expand...
Click here to expand...
Click here to expand...
Click here to expand...
Click here to expand...
Click here to expand...
1@Execution (ExecutionMode .CONCURRENT )
This line tells the JUnit engine that the tests in this class were designed to run one after the other, without paralleling. Note! In order use 
JUnit parallel mechanism, there is a property file named junit-platform.properties located at src/test/resources folder
1public class BasicMobileExampleTests  extends BaseTest  {
We extend the class BaseTest. BaseTest is a class that was created in the examples repo. It mainly holds the annotations and keeps 
this code clean. 
1@DriverUrl
2private URL url = new URL("http://127.0.0.1:4723/wd/hub/" );
There are 3 main annotations you will need to be familiar with in order to get your driver up without any issues: @DriverCapabilities, 
@DriverUrl, and @DriverCommandExecutor.
The  @DriverUrl tells the VeriSoftDriver where to find the url to use when starting up. We use dependency injection for injecting the 
WebDriver directly into the test. More on our dependency injection mechanism for the driver can be found here. Note the /wd/hub at the 
end.
1@DriverCapabilities
2private DesiredCapabilities  capabilities = new DesiredCapabilities ();
The  @DriverCapabilities tells the VeriSoftDriver where to find the DesiredCapabilities to use when starting up. We use dependency 
injection for injecting the WebDriver directly into the test. 
1@Test
2@DisplayName ("Click On Element" )
Both lines are JUnit lines. The @DisplayName line is very important since if you use this annotation, then most of the report 
mechanisms will use it as the test name, rather than the method name.
1    public void clickOnElement (VerisoftMobileDriver  driver) {
We use a dependency injection mechanism, which takes the @DriverCapabilities, @DriverUrl, and @DriverCommandExecutor (if 
present) and creates an instance of VerisoftDriver. The VerisoftDriver object is an instance of WebDriver and follows its 
interfaces and more. More about the VeriSoftDriver and VerisoftMobileDriver can be found here.
1// Note!! Verisoft Assert
2String phrase = "No thanks" ;Click here to expand...
Click here to expand...
 
Well, thatâ€™s it! We made it through a basic web UI test. Here is the complete code, and you can also view it on Bitbucket
3Asserts.assertTrue (e.getText().contains (phrase), "Page should contain the pharase: "  + phrase);
Asserts in the Verisoft framework do pretty much the same as regular asserts. The difference here is that we log the message to the 
various logging and reporting mechanisms that are listening to out Observer Report mechanism. More about the Report in the following 
line. You may choose to use a different Assert mechanism (and there are plenty of those in Java, but you will lose this nice logging 
feature.
1Report.info("Got to this point - We are operating Google chrome on mobile deviceS" );
There are many places we want to write reports to - logging, report mechanism, perhaps a global logging system like Splunk, Jira,, etc. 
If we would write a line of code for each of the mechanisms we support, we would have more logging lines of code than actual code. 
So, we use the Observer pattern and use one single Report object to write to all of them. More about the Report object here.
1@Execution (ExecutionMode .SAME_THREAD )
2public class BasicMobileExampleTests  extends BaseTest  {
3
4    @DriverUrl
5    private URL url = new URL("http://127.0.0.1:4723/wd/hub/" );
6
7    @DriverCapabilities
8    private DesiredCapabilities  capabilities = new DesiredCapabilities ();
9
10    {
11        capabilities .setCapability (MobileCapabilityType .PLATFORM_NAME , "Android" );
12        capabilities .setCapability ("appPackage" , "com.android.chrome" );
13        capabilities .setCapability ("appActivity" , 
14                              "com.google.android.apps.chrome.Main" );
15        capabilities .setCapability ("automationName" , "UIAutomator2" );
16    }
17
18
19    public BasicMobileExampleTests () throws MalformedURLException  {
20    }
21
22
23    @Test
24    @DisplayName ("Click On Element" )
25    public void clickOnElement (VerisoftMobileDriver  driver) {
26
27        driver .findElement (By.id("com.android.chrome:id/terms_accept" )).click();
28        WebElement  e = 
29              Waits.visibilityOfElementLocated (driver, 30, 
30                       By.id("com.android.chrome:id/negative_button" ));
31
32        // Note!! Verisoft Assert
33        String phrase = "No thanks" ;
34        Asserts.assertTrue (e.getText().contains (phrase), 
35                            "Page should contain the pharase: "  + phrase);
36
37        Report.info("Got to this point - We are operating Google chrome on mobile" );
38    } 
39}