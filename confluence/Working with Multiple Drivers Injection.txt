Working with Multiple Drivers Injection
Setting Up Multiple Drivers for Your Test
You can configure more than one driver for your test. For instance, if you need to test a website in Chrome, receive an SMS message on 
your mobile, and then return to the website, you can do so using multiple drivers. Each driver can be initialized with specific capabilities and 
a URL, as well as a dedicated CommandExecutor.
Initializing Specific Driver Capabilities
There are three methods to initialize specific capabilities for a driver:
1. Extracting from a JSON File
Define the capabilities in a JSON file with the following format:
Specify the path to this file in the application properties file as follows:
If no path is defined, the default is src/test/resources/capabilities.json.
To use these capabilities, reference the name in your test method:
2. By Bean Injection
Use Spring injection to define capabilities. Define a configuration class:
1[
2  {
3    "name": "chromeJson" ,
4    "caps": {
5      "browserName" : "chrome"
6    }
7  },
8  {
9    "name": "edgeJson" ,
10    "caps": {
11      "browserName" : "MicrosoftEdge"
12    }
13  },
14  {
15    "name": "mobileJson" ,
16    "caps": {
17      "platformName" : "Android" ,
18      "platformVersion" : "14"
19    }
20  }
21]
1capabilities.file.path=./src/test/resources/my_capabilities.json
1@Test
2public void twoDriversWithJsonCapabilities (@DriverCapabilities ("chromeJson" ) VerisoftDriver  chromeDriver ,
3                                           @DriverCapabilities ("edgeJson" ) VerisoftDriver  edgeDriver ) {}
1@Configuration
2@ComponentScan ("co.verisoft.examples" )
3public class CapabilitiesInjection  {In your test class, include this configuration:
Reference the bean name in your test method:
3. By Field in the Test Class
If no specific capabilities are defined, the driver will use the capabilities defined in the class field:
Usage: (The  edge driver will use the EdgeOptions capabilities)
Initializing a Specific URL for the Driver
There are three options for initializing a specific URL for the driver:
1. Hard-coded in Annotation:
2. By Bean Injection: (add this bean to CapabilitiesInjection class)
Usage:
4    @Bean("chrome" )
5    @Primary
6    public Capabilities  getChromeCapabilities () {
7        ChromeOptions  options = new ChromeOptions ();
8        options .addArguments ("--no-sandbox" , "--headless" );
9        return options ;
10    }
11
12    @Bean("edge")
13    public Capabilities  getEdgeCapabilities () {
14        EdgeOptions  options = new EdgeOptions ();
15        options .addArguments ("--no-sandbox" );
16        return options ;
17    }
18}
1@ExtendWith ({SpringExtension .class, DriverInjectionExtension .class, ScreenShotExtension .class})
2@ContextConfiguration (classes = {CapabilitiesInjection .class})
3public class MultipleDriversTests  {}
1@Test
2public void twoDriversWithBeanCapabilities (@DriverCapabilities ("chrome" ) VerisoftDriver  chromeDriver ,
3                                           @DriverCapabilities ("edge") VerisoftDriver  edgeDriver ) {}
1@DriverCapabilities
2EdgeOptions  options = new EdgeOptions ();
3{
4    options .addArguments ("--headless" );
5}
1@Test
2public void twoDriversWithFieldCapabilities (@DriverCapabilities ("chrome" ) VerisoftDriver  chromeDriver ,
3                                            VerisoftDriver  edgeDriver ) {}
1@Test
2public void driverWithHardCodedURL (@DriverCapabilities ("chrome" ) @DriverUrl ("<http://1.2.3.4:4444/wd/hub/>" ) V
1@Bean("seleniumGridUrl" )
2public URL getSeleniumGridUrl () throws MalformedURLException  {
3    return new URL("<http://1.2.3.4:4444/wd/hub/>" );
4}3. By Field in the Class:
Usage:
Initializing DriverCommandExecutor
There are three methods to initialize DriverCommandExecutor:
1. By Sending the Name of the Proxy Class:
2. By Bean Injection:
Usage:
3. By Field in the Class:
Usage:
This structured approach allows you to manage multiple drivers efficiently in your testing environment.
The @DriverName Annotation
The @DriverName annotation is used to assign a unique name to each driver managed by the VerisoftDriverManager. This allows for 
easy retrieval of specific drivers by name within your tests.
Assigning Names to Drivers
To assign a name to a driver, use the @DriverName annotation. You can then retrieve the driver by its name as shown in the example 
below:
1@Test
2public void driverWithUrlBean (@DriverCapabilities ("chrome" ) @DriverUrl ("seleniumGridUrl" ) VerisoftDriver  chrom
1@DriverUrl
2String url = "<http://1.2.3.4:4444/wd/hub/>" ;
1@Test
2public void driverWithFieldURL (@DriverCapabilities ("chrome" ) VerisoftDriver  chromeDriver ) {}
1@Test
2public void driverWithProxyCommandExecutor (@DriverCapabilities ("mobileJson" ) @DriverCommandExecutor ("org.openq
1@Bean("command Executor" )
2   public HttpCommandExecutor  getCommandExecutor () throws MalformedURLException  {
3       URL serverUrl = new URL("http://127.0.0.1:4723/wd/hub/" );
4       return new AppiumCommandExecutor (MobileCommand .commandRepository , serverUrl );
5   }
6
1@Test
2public void driverWithExecutorBean (@DriverCapabilities ("mobileLeumi" ) @DriverCommandExecutor ("commandExecutor" ) V
1@DriverCommandExecutor
2private HttpCommandExecutor  commandExecutor = new AppiumCommandExecutor (MobileCommand .commandRepository , new U
1@Test
2public void driverWithFieldExecutor (@DriverCapabilities ("mobilejson" ) VerisoftMobileDriver  driver) {}
1@Test
2public void getDriverByName(@DriverName("my driver name") VerisoftDriver driver) {In this example, @DriverName("my driver name") assigns the name "my driver name" to driver. The 
VerisoftDriverManager.getDriver(String driverName) method is then used to retrieve the driver by its name.
If there is one driver, it can be retrieved by VerisoftDriverManager.getDriver() without a specific name.
If no name is provided for a driver and your test involves multiple drivers, the VerisoftDriverManager.getDriver()will throw an error. 
You should give it a name so you can retrieve it if there is more than one driver.
Retrieving All Drivers
You can retrieve a map of all drivers currently managed within the test using the following method:
This method returns a map where each key is the name of a driver and each value is the corresponding VerisoftDriver instance.
Using the @DriverName annotation simplifies the management and utilization of multiple drivers in complex testing scenarios, ensuring that 
each driver can be uniquely identified and accessed as needed.
 
Happy Coding!
3    VerisoftDriver extractedDriver = VerisoftDriverManager.getDriver("my driver name");
4}
5
1Map<String, VerisoftDriver> allDrivers = VerisoftDriverManager.getDrivers();