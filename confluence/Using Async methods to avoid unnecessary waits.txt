Using Async methods to avoid unnecessary waits
The use case
Say you need to automate a website. And the website has a popup that appears asynchronously after an amount of time. You cannot ignore 
the popup, since it will sooner or later block your script. So you have one of 2 choices: 1. Wait for the popup, and block the execution of the 
script 2. Run an asyncjs using WebDriver JavaScriptExecutor
Since option 2, unfortunately, runs the script asynchronously on the web page but still blocks selenium, we are left with only one choice, 
really, which is to wait and block other execution until the popup is dismissed.
Selenium is a single thread application, so is javascript
The main constraint is that Selenium WebDriver is a single-thread application. It does not work with multi-thread. So how can we run 
asynchronous tests? Well, Javascript is a single thread as well. Javascript has an internal mechanism for running on the same thread async 
actions. Async, not parallel. In order to run async, we need to hook into places in the execution. Luckily, we have EventFiringWebDriver 
exactly for this point.
How does Selenium.Async work?
We hooked into the most basic comment a standard Selenium script does - search for elements (findElement and findElements). So 
the basic concept would be: 1. Define an async piece of code. 2. Register it to be executed. 3. Perform a regular selenium script that 
involves findElement and/or findElements.
That's it....
The feature is heavily documented, you can check it out. Take a look at the unit tests for gettings started examples
Examples
Example 1 - register the listener with the driver
Example 2 - print the title of the page async to the display
1WebDriver  driver;
2
3asyncListener = new AsyncListener ();
4driver = new EventFiringWebDriver (new FirefoxDriver ());
5((EventFiringWebDriver )driver).register (asyncListener );
1AsyncListener  listener = new AsyncListener ();
2listener .setDispatchInterval (2, ChronoUnit .SECONDS);
3((EventFiringWebDriver )driver).register (listener );
4
5Observer  o = new AsyncTask (driver, new SeleniumTask () {
6
7@Override
8public boolean doTask() {
9    String pageTitle = driver.getCurrentUrl ();
10    System.out.println("Time is "  + LocalTime .now() + ", page url is "  + pageTitle );Example 3 - Wait for a pop up and dismiss it
 
Using the Async Feature in the Verisoft Framework - An Example
In the VerisoftDriver object, there is built-in support for the async operation. Here is an example
11    return false;
12}
13});
14
15listener .register (o);
1AsyncListener listener = new AsyncListener();
2listener.setDispatchInterval(2, ChronoUnit.SECONDS);
3((EventFiringWebDriver)driver).register(listener);
4
5Observer o = new AsyncTask(driver, new SeleniumTask() {
6    @Override
7    public boolean doTask() {
8        boolean result = false;
9
10        List<WebElement> elements = driver.findElements(By.id("popup-button-dismiss-locator"));
11        if (elements.isEmpty())
12            return false;
13
14        try{
15            elements.get(0).click();
16            result = true;
17        }
18        catch(Throwable t){
19            result = false;
20        }
21
22        return result;
23    }
24});
25
26listener.register(o);
1@Test
2public void shouldInvokeAsyncOperationOnceAfterFindBy (VerisoftDriver  driver) 
3                                                           throws InterruptedException  {
4    driver .get(pageTestUrl );
5
6    // Set the async task
7    Observer  o = new AsyncTask (driver, () -> {
8        driver .findElement (By.id("texta")).sendKeys ("test1");
9        return true;
10    });
11    driver .async().register (o);
12
13    // Default dispatch is 5 second
14    Thread.sleep(5500);
15    driver .findElement (By.id("texta"));
16    String text = (String) driver.executeScript ("return document .getElementById ('texta') 
17                                                                                  .value");
18
19    // Note!! Verisoft Assert
20    Asserts.assertEquals ("test1", text, "text should have been "  + "test1");
21}